plugins {
  id 'java'
  id 'application'
  id 'com.github.johnrengelman.shadow' version '8.1.1'
}

repositories { 
  mavenCentral()
  mavenLocal()  // For local polyglot dependency
}

java { toolchain { languageVersion = JavaLanguageVersion.of(21) } }

dependencies {
  // --- Runtime deps for WALA source-mode slicing ---
  implementation 'com.ibm.wala:com.ibm.wala.core:1.6.12'
  implementation 'com.ibm.wala:com.ibm.wala.util:1.6.12'
  implementation 'com.ibm.wala:com.ibm.wala.shrike:1.6.12'
  implementation 'com.ibm.wala:com.ibm.wala.cast:1.6.12'
  implementation 'com.ibm.wala:com.ibm.wala.cast.java:1.6.12'

  // ECJ front-end (source mode)
  // (1.6.10 is the latest ecj wrapper on Maven Central right now; it's OK to mix with 1.6.12 core)
  implementation 'com.ibm.wala:com.ibm.wala.cast.java.ecj:1.6.10'

  // Some environments still need Polyglot classes present even with ECJ. Include it to be safe.
  // Use local Polyglot JAR files
  implementation files('polyglot-2.8.0-src/lib/polyglot.jar')
  implementation files('polyglot-2.8.0-src/lib/java_cup.jar')
  implementation files('polyglot-2.8.0-src/lib/jflex.jar')
  implementation files('polyglot-2.8.0-src/lib/ppg.jar')
  implementation files('polyglot-2.8.0-src/lib/pth.jar')
  implementation files('polyglot-2.8.0-src/lib/efg.jar')

  // Eclipse compiler (helps in some setups)
  implementation 'org.eclipse.jdt:ecj:3.33.0'

  // Checker Framework jars (needed to compile CF test sources for WALA bytecode mode)
  implementation fileTree(dir: '/home/ubuntu/checker-framework-3.42.0/checker/dist', include: ['*.jar'])
  
  // Checker Framework dataflow (for CFG Builder)
  implementation files('/home/ubuntu/checker-framework/dataflow/build/libs/dataflow-errorprone-3.51.1-SNAPSHOT-all.jar')
  
  // javax.annotation-api (needed for @Nonnegative etc. in CF tests)
  implementation 'javax.annotation:javax.annotation-api:1.3.2'

  // Your parser
  implementation 'com.github.javaparser:javaparser-core:3.26.2'

  // Soot for bytecode analysis and slicing
  implementation 'org.soot-oss:soot:4.4.1'
  
  // Vineflower decompiler (optional)
  implementation 'org.vineflower:vineflower:1.10.1'

  // --- Tests (choose JUnit 5 or 4; here we use JUnit 5) ---
  testImplementation 'org.junit.jupiter:junit-jupiter:5.10.3'
  testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.3'
  testImplementation 'org.assertj:assertj-core:3.25.3'
  testImplementation 'net.jqwik:jqwik:1.8.2'
  testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
}

test { useJUnitPlatform() }

/**
 * The 'application' plugin's default run target = your resolver
 * so `./gradlew run -PappArgs="..."` still works for the resolver flow.
 */
application {
  mainClass = 'cfwr.CheckerFrameworkWarningResolver'
}

/**
 * Build a fat JAR for the WALA slicer CLI with the correct Main-Class.
 * Output: build/libs/wala-slicer-all.jar
 */
// Build a fat JAR for the WALA slicer CLI with the correct Main-Class
tasks.register('walaSlicerJar', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
  group = 'build'
  description = 'Build a fat JAR for the WALA slicer CLI'
  archiveBaseName.set('wala-slicer')
  archiveClassifier.set('all')
  archiveVersion.set('') // nicer filename

  from sourceSets.main.output
  configurations = [project.configurations.runtimeClasspath]

  // CRITICAL: keep ServiceLoader entries so WALA can discover ECJ loader, etc.
  mergeServiceFiles {
    include 'META-INF/services/*'
  }

  // Optional: some libs ship duplicate module-info; this avoids noise
  exclude 'module-info.class'
  exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'

  manifest { attributes 'Main-Class': 'cfwr.WalaSliceCLI' }
}

/**
 * Build a fat JAR for the Checker Framework slicer CLI.
 * Output: build/libs/cf-slicer-all.jar
 */
tasks.register('cfSlicerJar', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
  group = 'build'
  description = 'Build a fat JAR for the Checker Framework slicer CLI'
  archiveBaseName.set('cf-slicer')
  archiveClassifier.set('all')
  archiveVersion.set('') // nicer filename

  from sourceSets.main.output
  configurations = [project.configurations.runtimeClasspath]

  // CRITICAL: keep ServiceLoader entries
  mergeServiceFiles {
    include 'META-INF/services/*'
  }

  // Optional: some libs ship duplicate module-info; this avoids noise
  exclude 'module-info.class'
  exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'

  manifest { attributes 'Main-Class': 'cfwr.CheckerFrameworkSlicer' }
}

/**
 * Optional convenience tasks to run either entrypoint without switching 'application.mainClass'
 */

// Run the WALA slicer CLI from Gradle (no jar needed)
tasks.register('runWalaSlice', JavaExec) {
  group = 'application'
  description = 'Run the WALA-based slicer CLI'
  classpath = sourceSets.main.runtimeClasspath
  mainClass = 'cfwr.WalaSliceCLI'
  if (project.hasProperty('args')) {
    args project.property('args').toString().split('\\s+')
  }
}

// Run the Checker Framework slicer CLI from Gradle (no jar needed)
tasks.register('runCFSlice', JavaExec) {
  group = 'application'
  description = 'Run the Checker Framework-based slicer CLI'
  classpath = sourceSets.main.runtimeClasspath
  mainClass = 'cfwr.CheckerFrameworkSlicer'
  if (project.hasProperty('args')) {
    args project.property('args').toString().split('\\s+')
  }
}

// Run the resolver explicitly
tasks.register('runResolver', JavaExec) {
  group = 'application'
  description = 'Run the CheckerFrameworkWarningResolver'
  classpath = sourceSets.main.runtimeClasspath
  mainClass = 'cfwr.CheckerFrameworkWarningResolver'
  if (project.hasProperty('args')) {
    args project.property('args').toString().split('\\s+')
  }
}

/**
 * Optional: keep your validate aggregate
 */
tasks.register('validate') {
  group = 'Verification'
  description = 'Runs build and tests'
  dependsOn 'build', 'test'
}
